<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>x86 and x86-64 SMT semantics supported</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libTriton
   &#160;<span id="projectnumber">version 0.9 build 1503</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">x86 and x86-64 SMT semantics supported </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<b>internal</b>] List of the supported semantics for the x86 and x86-64 architectures.</p>
<table class="doxtable">
<tr>
<th>Mnemonic </th><th>Extensions </th><th>Description  </th></tr>
<tr>
<td>AAA </td><td></td><td>ASCII Adjust After Addition </td></tr>
<tr>
<td>AAD </td><td></td><td>ASCII Adjust AX Before Division </td></tr>
<tr>
<td>AAM </td><td></td><td>ASCII Adjust AX After Multiply </td></tr>
<tr>
<td>AAS </td><td></td><td>ASCII Adjust AL After Subtraction </td></tr>
<tr>
<td>ADC </td><td></td><td>Add with Carry </td></tr>
<tr>
<td>ADCX </td><td>adx </td><td>Unsigned Integer Addition of Two Operands with Carry Flag </td></tr>
<tr>
<td>ADD </td><td></td><td>Add </td></tr>
<tr>
<td>AND </td><td></td><td>Logical AND </td></tr>
<tr>
<td>ANDN </td><td>bmi1 </td><td>Logical AND NOT </td></tr>
<tr>
<td>ANDNPD </td><td>sse2 </td><td>Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>ANDNPS </td><td>sse1 </td><td>Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>ANDPD </td><td>sse2 </td><td>Bitwise Logical AND of Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>ANDPS </td><td>sse1 </td><td>Bitwise Logical AND of Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>BEXTR </td><td>bmi1/tbm </td><td>Bit Field Extract </td></tr>
<tr>
<td>BLSI </td><td>bmi1 </td><td>Extract Lowest Set Isolated Bit </td></tr>
<tr>
<td>BLSMSK </td><td>bmi1 </td><td>Get Mask Up to Lowest Set Bit </td></tr>
<tr>
<td>BLSR </td><td>bmi1 </td><td>Reset Lowest Set Bit </td></tr>
<tr>
<td>BSF </td><td></td><td>Bit Scan Forward </td></tr>
<tr>
<td>BSR </td><td></td><td>Bit Scan Reverse </td></tr>
<tr>
<td>BSWAP </td><td></td><td>Byte Swap </td></tr>
<tr>
<td>BT </td><td></td><td>Bit Test </td></tr>
<tr>
<td>BTC </td><td></td><td>Bit Test and Complement </td></tr>
<tr>
<td>BTR </td><td></td><td>Bit Test and Reset </td></tr>
<tr>
<td>BTS </td><td></td><td>Bit Test and Set </td></tr>
<tr>
<td>CALL </td><td></td><td>Call Procedure </td></tr>
<tr>
<td>CBW </td><td></td><td>Convert byte (al) to word (ax) </td></tr>
<tr>
<td>CDQ </td><td></td><td>Convert dword (eax) to qword (edx:eax) </td></tr>
<tr>
<td>CDQE </td><td></td><td>Convert dword (eax) to qword (rax) </td></tr>
<tr>
<td>CLC </td><td></td><td>Clear Carry Flag </td></tr>
<tr>
<td>CLD </td><td></td><td>Clear Direction Flag </td></tr>
<tr>
<td>CLFLUSH </td><td>sse2 </td><td>Flush Cache Line </td></tr>
<tr>
<td>CLI </td><td></td><td>Clear Interrupt Flag </td></tr>
<tr>
<td>CLTS </td><td></td><td>Clear Task-Switched Flag in CR0 </td></tr>
<tr>
<td>CMC </td><td></td><td>Complement Carry Flag </td></tr>
<tr>
<td>CMOVA </td><td></td><td>Move if not below </td></tr>
<tr>
<td>CMOVAE </td><td></td><td>Move if not below or equal </td></tr>
<tr>
<td>CMOVB </td><td></td><td>Move if below </td></tr>
<tr>
<td>CMOVBE </td><td></td><td>Move if below or equal </td></tr>
<tr>
<td>CMOVE </td><td></td><td>Move if zero </td></tr>
<tr>
<td>CMOVG </td><td></td><td>Move if not less </td></tr>
<tr>
<td>CMOVGE </td><td></td><td>Move if not less or equal </td></tr>
<tr>
<td>CMOVL </td><td></td><td>Move if less </td></tr>
<tr>
<td>CMOVLE </td><td></td><td>Move if less or equal </td></tr>
<tr>
<td>CMOVNE </td><td></td><td>Move if not zero </td></tr>
<tr>
<td>CMOVNO </td><td></td><td>Move if not overflow </td></tr>
<tr>
<td>CMOVNP </td><td></td><td>Move if not parity </td></tr>
<tr>
<td>CMOVNS </td><td></td><td>Move if not sign </td></tr>
<tr>
<td>CMOVO </td><td></td><td>Move if overflow </td></tr>
<tr>
<td>CMOVP </td><td></td><td>Move if parity </td></tr>
<tr>
<td>CMOVS </td><td></td><td>Move if sign </td></tr>
<tr>
<td>CMP </td><td></td><td>Compare Two Operands </td></tr>
<tr>
<td>CMPSB </td><td></td><td>Compare byte at address </td></tr>
<tr>
<td>CMPSD </td><td></td><td>Compare doubleword at address </td></tr>
<tr>
<td>CMPSQ </td><td></td><td>Compare quadword at address </td></tr>
<tr>
<td>CMPSW </td><td></td><td>Compare word at address </td></tr>
<tr>
<td>CMPXCHG </td><td></td><td>Compare and Exchange </td></tr>
<tr>
<td>CMPXCHG16B </td><td></td><td>Compare and Exchange 16 Bytes </td></tr>
<tr>
<td>CMPXCHG8B </td><td></td><td>Compare and Exchange 8 Bytes </td></tr>
<tr>
<td>CPUID </td><td></td><td>CPU Identification </td></tr>
<tr>
<td>CQO </td><td></td><td>Convert qword (rax) to oword (rdx:rax) </td></tr>
<tr>
<td>CWD </td><td></td><td>Convert word (ax) to dword (dx:ax) </td></tr>
<tr>
<td>CWDE </td><td></td><td>Convert word (ax) to dword (eax) </td></tr>
<tr>
<td>DEC </td><td></td><td>Decrement by 1 </td></tr>
<tr>
<td>DIV </td><td></td><td>Unsigned Divide </td></tr>
<tr>
<td>ENDBR32 </td><td></td><td>No Operation </td></tr>
<tr>
<td>ENDBR64 </td><td></td><td>No Operation </td></tr>
<tr>
<td>EXTRACTPS </td><td>sse4.1 </td><td>Extract Packed Single Precision Floating-Point Value </td></tr>
<tr>
<td>IDIV </td><td></td><td>Signed Divide </td></tr>
<tr>
<td>IMUL </td><td></td><td>Signed Multiply </td></tr>
<tr>
<td>INC </td><td></td><td>Increment by 1 </td></tr>
<tr>
<td>INVD </td><td></td><td>Invalidate Internal Caches </td></tr>
<tr>
<td>INVLPG </td><td></td><td>Invalidate TLB Entry </td></tr>
<tr>
<td>JA </td><td></td><td>Jump if not below (Jump if above) </td></tr>
<tr>
<td>JAE </td><td></td><td>Jump if not below or equal (Jump if above or equal) </td></tr>
<tr>
<td>JB </td><td></td><td>Jump if below </td></tr>
<tr>
<td>JBE </td><td></td><td>Jump if below or equal </td></tr>
<tr>
<td>JCXZ </td><td></td><td>Jump if cx is zero </td></tr>
<tr>
<td>JE </td><td></td><td>Jump if zero (Jump if equal) </td></tr>
<tr>
<td>JECXZ </td><td></td><td>Jump if ecx is zero </td></tr>
<tr>
<td>JG </td><td></td><td>Jump if not less or equal (Jump if greater) </td></tr>
<tr>
<td>JGE </td><td></td><td>Jump if not less (Jump if not less) </td></tr>
<tr>
<td>JL </td><td></td><td>Jump if less </td></tr>
<tr>
<td>JLE </td><td></td><td>Jump if less or equal </td></tr>
<tr>
<td>JMP </td><td></td><td>Jump </td></tr>
<tr>
<td>JNE </td><td></td><td>Jump if not equal </td></tr>
<tr>
<td>JNO </td><td></td><td>Jump if not overflow </td></tr>
<tr>
<td>JNP </td><td></td><td>Jump if not parity </td></tr>
<tr>
<td>JNS </td><td></td><td>Jump if not sign </td></tr>
<tr>
<td>JO </td><td></td><td>Jump if overflow </td></tr>
<tr>
<td>JP </td><td></td><td>Jump if parity </td></tr>
<tr>
<td>JRCXZ </td><td></td><td>Jump if rcx is zero </td></tr>
<tr>
<td>JS </td><td></td><td>Jump if sign </td></tr>
<tr>
<td>LAHF </td><td></td><td>Load Status Flags into AH Register </td></tr>
<tr>
<td>LDDQU </td><td>sse3 </td><td>Load Unaligned Integer 128 Bits </td></tr>
<tr>
<td>LDMXCSR </td><td>sse1 </td><td>Load MXCSR Register </td></tr>
<tr>
<td>LEA </td><td></td><td>Load Effective Address </td></tr>
<tr>
<td>LEAVE </td><td></td><td>High Level Procedure Exit </td></tr>
<tr>
<td>LFENCE </td><td>sse2 </td><td>Load Fence </td></tr>
<tr>
<td>LODSB </td><td></td><td>Load byte at address </td></tr>
<tr>
<td>LODSD </td><td></td><td>Load doubleword at address </td></tr>
<tr>
<td>LODSQ </td><td></td><td>Load quadword at address </td></tr>
<tr>
<td>LODSW </td><td></td><td>Load word at address </td></tr>
<tr>
<td>LOOP </td><td></td><td>Loop According to ECX Counter </td></tr>
<tr>
<td>LZCNT </td><td></td><td>Count the Number of Leading Zero Bits </td></tr>
<tr>
<td>MFENCE </td><td>sse2 </td><td>Memory Fence </td></tr>
<tr>
<td>MOV </td><td></td><td>Move </td></tr>
<tr>
<td>MOVABS </td><td></td><td>Move </td></tr>
<tr>
<td>MOVAPD </td><td>sse2 </td><td>Move Aligned Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVAPS </td><td>sse1 </td><td>Move Aligned Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVBE </td><td>mmx/sse2 </td><td>Move Data After Swapping Bytes </td></tr>
<tr>
<td>MOVD </td><td>mmx/sse2 </td><td>Move Doubleword </td></tr>
<tr>
<td>MOVDDUP </td><td>sse3 </td><td>Move One Double-FP and Duplicate </td></tr>
<tr>
<td>MOVDQ2Q </td><td>sse2 </td><td>Move Quadword from XMM to MMX Technology Register </td></tr>
<tr>
<td>MOVDQA </td><td>sse2 </td><td>Move Aligned Double Quadword </td></tr>
<tr>
<td>MOVDQU </td><td>sse2 </td><td>Move Unaligned Double Quadword </td></tr>
<tr>
<td>MOVHLPS </td><td>sse1 </td><td>Move Packed Single-Precision Floating-Point Values High to Low </td></tr>
<tr>
<td>MOVHPD </td><td>sse2 </td><td>Move High Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVHPS </td><td>sse1 </td><td>Move High Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVLHPS </td><td>sse1 </td><td>Move Packed Single-Precision Floating-Point Values Low to High </td></tr>
<tr>
<td>MOVLPD </td><td>sse2 </td><td>Move Low Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVLPS </td><td>sse1 </td><td>Move Low Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>MOVMSKPD </td><td>sse2 </td><td>Extract Packed Double-Precision Floating-Point Sign Mask </td></tr>
<tr>
<td>MOVMSKPS </td><td>sse1 </td><td>Extract Packed Single-Precision Floating-Point Sign Mask </td></tr>
<tr>
<td>MOVNTDQ </td><td>sse2 </td><td>Store Double Quadword Using Non-Temporal Hint </td></tr>
<tr>
<td>MOVNTI </td><td>sse2 </td><td>Store Doubleword Using Non-Temporal Hint </td></tr>
<tr>
<td>MOVNTPD </td><td>sse2 </td><td>Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint </td></tr>
<tr>
<td>MOVNTPS </td><td>sse1 </td><td>Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint </td></tr>
<tr>
<td>MOVNTQ </td><td>sse1 </td><td>Store of Quadword Using Non-Temporal Hint </td></tr>
<tr>
<td>MOVQ </td><td>mmx/sse2 </td><td>Move Quadword </td></tr>
<tr>
<td>MOVQ2DQ </td><td>sse2 </td><td>Move Quadword from MMX Technology to XMM Register </td></tr>
<tr>
<td>MOVSB </td><td></td><td>Move byte at address </td></tr>
<tr>
<td>MOVSD </td><td></td><td>Move doubleword at address </td></tr>
<tr>
<td>MOVSHDUP </td><td>sse3 </td><td>Move Packed Single-FP High and Duplicate </td></tr>
<tr>
<td>MOVSLDUP </td><td>sse3 </td><td>Move Packed Single-FP Low and Duplicate </td></tr>
<tr>
<td>MOVSQ </td><td></td><td>Move quadword at address </td></tr>
<tr>
<td>MOVSW </td><td></td><td>Move word at address </td></tr>
<tr>
<td>MOVSX </td><td></td><td>Move with Sign-Extension </td></tr>
<tr>
<td>MOVSXD </td><td></td><td>Move with Sign-Extension </td></tr>
<tr>
<td>MOVUPD </td><td>see2 </td><td>Move Unaligned Packed Double-Precision Floating- Point Values </td></tr>
<tr>
<td>MOVUPS </td><td>see1 </td><td>Move Unaligned Packed Single-Precision Floating- Point Values </td></tr>
<tr>
<td>MOVSS </td><td>sse1 </td><td>Move Scalar Single-Precision Floating- Point Values </td></tr>
<tr>
<td>MOVZX </td><td></td><td>Move with Zero-Extend </td></tr>
<tr>
<td>MUL </td><td></td><td>Unsigned Multiply </td></tr>
<tr>
<td>MULX </td><td>bmi2 </td><td>Unsigned Multiply Without Affecting Flags </td></tr>
<tr>
<td>NEG </td><td></td><td>Two's Complement Negation </td></tr>
<tr>
<td>NOP </td><td></td><td>No Operation </td></tr>
<tr>
<td>NOT </td><td></td><td>One's Complement Negation </td></tr>
<tr>
<td>OR </td><td></td><td>Logical Inclusive OR </td></tr>
<tr>
<td>ORPD </td><td>sse2 </td><td>Bitwise Logical OR of Double-Precision Floating-Point Values </td></tr>
<tr>
<td>ORPS </td><td>sse1 </td><td>Bitwise Logical OR of Single-Precision Floating-Point Values </td></tr>
<tr>
<td>PACKUSWB </td><td>mmx/sse2 </td><td>Pack with unsigned saturation </td></tr>
<tr>
<td>PADDB </td><td>mmx/sse2 </td><td>Add packed byte integers </td></tr>
<tr>
<td>PADDD </td><td>mmx/sse2 </td><td>Add packed doubleword integers </td></tr>
<tr>
<td>PADDQ </td><td>mmx/sse2 </td><td>Add packed quadword integers </td></tr>
<tr>
<td>PADDW </td><td>mmx/sse2 </td><td>Add packed word integers </td></tr>
<tr>
<td>PALIGNR </td><td>sse3 </td><td>Packed Align Right </td></tr>
<tr>
<td>PAND </td><td>mmx/sse2 </td><td>Logical AND </td></tr>
<tr>
<td>PANDN </td><td>mmx/sse2 </td><td>Logical AND NOT </td></tr>
<tr>
<td>PAUSE </td><td>sse2 </td><td>Spin Loop Hint </td></tr>
<tr>
<td>PAVGB </td><td>sse1 </td><td>Average Packed Unsigned Byte Integers </td></tr>
<tr>
<td>PAVGW </td><td>sse1 </td><td>Average Packed Unsigned Word Integers </td></tr>
<tr>
<td>PCMPEQB </td><td>mmx/sse2 </td><td>Compare Packed Data for Equal (bytes) </td></tr>
<tr>
<td>PCMPEQD </td><td>mmx/sse2 </td><td>Compare Packed Data for Equal (dwords) </td></tr>
<tr>
<td>PCMPEQW </td><td>mmx/sse2 </td><td>Compare Packed Data for Equal (words) </td></tr>
<tr>
<td>PCMPGTB </td><td>mmx/sse2 </td><td>Compare Packed Data for Greater Than (bytes) </td></tr>
<tr>
<td>PCMPGTD </td><td>mmx/sse2 </td><td>Compare Packed Data for Greater Than (dwords) </td></tr>
<tr>
<td>PCMPGTW </td><td>mmx/sse2 </td><td>Compare Packed Data for Greater Than (words) </td></tr>
<tr>
<td>PEXTRB </td><td>sse4.1 </td><td>Extract Byte </td></tr>
<tr>
<td>PEXTRD </td><td>sse4.1 </td><td>Extract Dword </td></tr>
<tr>
<td>PEXTRQ </td><td>sse4.1 </td><td>Extract Qword </td></tr>
<tr>
<td>PEXTRW </td><td>sse4.1 </td><td>Extract Word </td></tr>
<tr>
<td>PINSRB </td><td>sse4.1 </td><td>Insert Byte </td></tr>
<tr>
<td>PINSRD </td><td>sse4.1 </td><td>Insert Dword </td></tr>
<tr>
<td>PINSRQ </td><td>sse4.1 </td><td>Insert Qword </td></tr>
<tr>
<td>PINSRW </td><td>sse2 </td><td>Insert Word </td></tr>
<tr>
<td>PMAXSB </td><td>sse4.1 </td><td>Maximum of Packed Signed Byte Integers </td></tr>
<tr>
<td>PMAXSD </td><td>sse4.1 </td><td>Maximum of Packed Signed Doubleword Integers </td></tr>
<tr>
<td>PMAXSW </td><td>sse1 </td><td>Maximum of Packed Signed Word Integers </td></tr>
<tr>
<td>PMAXUB </td><td>sse1 </td><td>Maximum of Packed Unsigned Byte Integers </td></tr>
<tr>
<td>PMAXUD </td><td>sse4.1 </td><td>Maximum of Packed Unsigned Doubleword Integers </td></tr>
<tr>
<td>PMAXUW </td><td>sse4.1 </td><td>Maximum of Packed Unsigned Word Integers </td></tr>
<tr>
<td>PMINSB </td><td>sse4.1 </td><td>Minimum of Packed Signed Byte Integers </td></tr>
<tr>
<td>PMINSD </td><td>sse4.1 </td><td>Minimum of Packed Signed Doubleword Integers </td></tr>
<tr>
<td>PMINSW </td><td>sse1 </td><td>Minimum of Packed Signed Word Integers </td></tr>
<tr>
<td>PMINUB </td><td>sse1 </td><td>Minimum of Packed Unsigned Byte Integers </td></tr>
<tr>
<td>PMINUD </td><td>sse4.1 </td><td>Minimum of Packed Unsigned Doubleword Integers </td></tr>
<tr>
<td>PMINUW </td><td>sse4.1 </td><td>Minimum of Packed Unsigned Word Integers </td></tr>
<tr>
<td>PMOVMSKB </td><td>sse1 </td><td>Move Byte Mask </td></tr>
<tr>
<td>PMOVSXBD </td><td>sse4.1 </td><td>Sign Extend 4 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVSXBQ </td><td>sse4.1 </td><td>Sign Extend 2 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVSXBW </td><td>sse4.1 </td><td>Sign Extend 8 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVSXDQ </td><td>sse4.1 </td><td>Sign Extend 2 Packed Signed 32-bit Integers </td></tr>
<tr>
<td>PMOVSXWD </td><td>sse4.1 </td><td>Sign Extend 4 Packed Signed 16-bit Integers </td></tr>
<tr>
<td>PMOVSXWQ </td><td>sse4.1 </td><td>Sign Extend 2 Packed Signed 16-bit Integers </td></tr>
<tr>
<td>PMOVZXBD </td><td>sse4.1 </td><td>Zero Extend 4 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVZXBQ </td><td>sse4.1 </td><td>Zero Extend 2 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVZXBW </td><td>sse4.1 </td><td>Zero Extend 8 Packed Signed 8-bit Integers </td></tr>
<tr>
<td>PMOVZXDQ </td><td>sse4.1 </td><td>Zero Extend 2 Packed Signed 32-bit Integers </td></tr>
<tr>
<td>PMOVZXWD </td><td>sse4.1 </td><td>Zero Extend 4 Packed Signed 16-bit Integers </td></tr>
<tr>
<td>PMOVZXWQ </td><td>sse4.1 </td><td>Zero Extend 2 Packed Signed 16-bit Integers </td></tr>
<tr>
<td>POP </td><td></td><td>Pop a Value from the Stack </td></tr>
<tr>
<td>POPAL/POPAD </td><td></td><td>Pop All General-Purpose Registers </td></tr>
<tr>
<td>POPF </td><td></td><td>Pop Stack into lower 16-bit of EFLAGS Register </td></tr>
<tr>
<td>POPFD </td><td></td><td>Pop Stack into EFLAGS Register </td></tr>
<tr>
<td>POPFQ </td><td></td><td>Pop Stack into RFLAGS Register </td></tr>
<tr>
<td>POR </td><td>mmx/sse2 </td><td>Bitwise Logical OR </td></tr>
<tr>
<td>PREFETCH </td><td>3DNow </td><td>Move data from m8 closer to the processor without expecting to write back </td></tr>
<tr>
<td>PREFETCHNTA </td><td>mmx/sse1 </td><td>Move data from m8 closer to the processor using NTA hint </td></tr>
<tr>
<td>PREFETCHT0 </td><td>mmx/sse1 </td><td>Move data from m8 closer to the processor using T0 hint </td></tr>
<tr>
<td>PREFETCHT1 </td><td>mmx/sse1 </td><td>Move data from m8 closer to the processor using T1 hint </td></tr>
<tr>
<td>PREFETCHT2 </td><td>mmx/sse1 </td><td>Move data from m8 closer to the processor using T2 hint </td></tr>
<tr>
<td>PREFETCHW </td><td>3DNow </td><td>Move data from m8 closer to the processor in anticipation of a write </td></tr>
<tr>
<td>PSHUFD </td><td>sse2 </td><td>Shuffle Packed Doublewords </td></tr>
<tr>
<td>PSHUFHW </td><td>sse2 </td><td>Shuffle Packed High Words </td></tr>
<tr>
<td>PSHUFLW </td><td>sse2 </td><td>Shuffle Packed Low Words </td></tr>
<tr>
<td>PSHUFW </td><td>sse1 </td><td>Shuffle Packed Words </td></tr>
<tr>
<td>PSLLD </td><td>mmx/ssed2 </td><td>Shift Doubleword Left Logical </td></tr>
<tr>
<td>PSLLDQ </td><td>sse2 </td><td>Shift Double Quadword Left Logical </td></tr>
<tr>
<td>PSLLQ </td><td>mmx/ssed2 </td><td>Shift Quadword Left Logical </td></tr>
<tr>
<td>PSLLW </td><td>mmx/ssed2 </td><td>Shift Word Left Logical </td></tr>
<tr>
<td>PSRLDQ </td><td>sse2 </td><td>Shift Double Quadword Right Logical </td></tr>
<tr>
<td>PSUBB </td><td>mmx/sse2 </td><td>Subtract packed byte integers </td></tr>
<tr>
<td>PSUBD </td><td>mmx/sse2 </td><td>Subtract packed doubleword integers </td></tr>
<tr>
<td>PSUBQ </td><td>mmx/sse2 </td><td>Subtract packed quadword integers </td></tr>
<tr>
<td>PSUBW </td><td>mmx/sse2 </td><td>Subtract packed word integers </td></tr>
<tr>
<td>PTEST </td><td>sse4.1 </td><td>Logical Compare </td></tr>
<tr>
<td>PUNPCKHBW </td><td>mmx,sse2 </td><td>Unpack High Data (Unpack and interleave high-order bytes) </td></tr>
<tr>
<td>PUNPCKHDQ </td><td>mmx,sse2 </td><td>Unpack High Data (Unpack and interleave high-order doublewords) </td></tr>
<tr>
<td>PUNPCKHQDQ </td><td>sse2 </td><td>Unpack High Data (Unpack and interleave high-order quadwords) </td></tr>
<tr>
<td>PUNPCKHWD </td><td>mmx,sse2 </td><td>Unpack High Data (Unpack and interleave high-order words) </td></tr>
<tr>
<td>PUNPCKLBW </td><td>mmx,sse2 </td><td>Unpack Low Data (Unpack and interleave low-order bytes) </td></tr>
<tr>
<td>PUNPCKLDQ </td><td>mmx,sse2 </td><td>Unpack Low Data (Unpack and interleave low-order doublewords) </td></tr>
<tr>
<td>PUNPCKLQDQ </td><td>sse2 </td><td>Unpack Low Data (Unpack and interleave low-order quadwords) </td></tr>
<tr>
<td>PUNPCKLWD </td><td>mmx,sse2 </td><td>Unpack Low Data (Unpack and interleave low-order words) </td></tr>
<tr>
<td>PUSH </td><td></td><td>Push a Value onto the Stack </td></tr>
<tr>
<td>PUSHAL/PUSHAD </td><td></td><td>Push All General-Purpose Registers </td></tr>
<tr>
<td>PUSHFD </td><td></td><td>Push EFLAGS Register onto the Stack </td></tr>
<tr>
<td>PUSHFQ </td><td></td><td>Push RFLAGS Register onto the Stack </td></tr>
<tr>
<td>PXOR </td><td>mmx/sse2 </td><td>Logical Exclusive OR </td></tr>
<tr>
<td>RCL </td><td></td><td>Rotate Left with Carry </td></tr>
<tr>
<td>RCR </td><td></td><td>Rotate Right with Carry </td></tr>
<tr>
<td>RDTSC </td><td></td><td>Read Time-Stamp Counter </td></tr>
<tr>
<td>RET </td><td></td><td>Return from Procedure </td></tr>
<tr>
<td>ROL </td><td></td><td>Rotate Left </td></tr>
<tr>
<td>ROR </td><td></td><td>Rotate Right </td></tr>
<tr>
<td>RORX </td><td>bmi2 </td><td>Rotate Right Logical Without Affecting Flags </td></tr>
<tr>
<td>SAHF </td><td></td><td>Store AH into Flags </td></tr>
<tr>
<td>SAL </td><td></td><td>Shift Left </td></tr>
<tr>
<td>SAR </td><td></td><td>Shift Right Signed </td></tr>
<tr>
<td>SARX </td><td>bmi2 </td><td>Shift arithmetic right without affecting flags </td></tr>
<tr>
<td>SBB </td><td></td><td>Integer Subtraction with Borrow </td></tr>
<tr>
<td>SCASB </td><td></td><td>Scan byte at address </td></tr>
<tr>
<td>SCASD </td><td></td><td>Scan doubleword at address </td></tr>
<tr>
<td>SCASQ </td><td></td><td>Scan quadword at address </td></tr>
<tr>
<td>SCASW </td><td></td><td>Scan word at address </td></tr>
<tr>
<td>SETA </td><td></td><td>Set byte if above </td></tr>
<tr>
<td>SETAE </td><td></td><td>Set byte if above or equal </td></tr>
<tr>
<td>SETB </td><td></td><td>Set byte if below </td></tr>
<tr>
<td>SETBE </td><td></td><td>Set byte if below or equal </td></tr>
<tr>
<td>SETE </td><td></td><td>Set byte if zero </td></tr>
<tr>
<td>SETG </td><td></td><td>Set byte if greater </td></tr>
<tr>
<td>SETGE </td><td></td><td>Set byte if greater or equal </td></tr>
<tr>
<td>SETL </td><td></td><td>Set byte if less </td></tr>
<tr>
<td>SETLE </td><td></td><td>Set byte if less or equal </td></tr>
<tr>
<td>SETNE </td><td></td><td>Set byte if not zero </td></tr>
<tr>
<td>SETNO </td><td></td><td>Set byte if not overflow </td></tr>
<tr>
<td>SETNP </td><td></td><td>Set byte if not parity </td></tr>
<tr>
<td>SETNS </td><td></td><td>Set byte if not sign </td></tr>
<tr>
<td>SETO </td><td></td><td>Set byte if overflow </td></tr>
<tr>
<td>SETP </td><td></td><td>Set byte if parity </td></tr>
<tr>
<td>SETS </td><td></td><td>Set byte if sign </td></tr>
<tr>
<td>SFENCE </td><td>sse1 </td><td>Store Fence </td></tr>
<tr>
<td>SHL </td><td></td><td>Shift Left </td></tr>
<tr>
<td>SHLD </td><td></td><td>Double-precision Shift Left </td></tr>
<tr>
<td>SHLX </td><td>bmi2 </td><td>Shift Logical Left Without Affecting Flags </td></tr>
<tr>
<td>SHR </td><td></td><td>Shift Right Unsigned </td></tr>
<tr>
<td>SHRD </td><td></td><td>Double Precision Shift Right </td></tr>
<tr>
<td>SHRX </td><td>bmi2 </td><td>Shift Logical Right Without Affecting Flags </td></tr>
<tr>
<td>STC </td><td></td><td>Set Carry Flag </td></tr>
<tr>
<td>STD </td><td></td><td>Set Direction Flag </td></tr>
<tr>
<td>STI </td><td></td><td>Set Interrupt Flag </td></tr>
<tr>
<td>STMXCSR </td><td>sse1 </td><td>Store MXCSR Register State </td></tr>
<tr>
<td>STOSB </td><td></td><td>Store byte at address </td></tr>
<tr>
<td>STOSD </td><td></td><td>Store doubleword at address </td></tr>
<tr>
<td>STOSQ </td><td></td><td>Store quadword at address </td></tr>
<tr>
<td>STOSW </td><td></td><td>Store word at address </td></tr>
<tr>
<td>SUB </td><td></td><td>Subtract </td></tr>
<tr>
<td>SYSCALL </td><td></td><td>Fast System Call </td></tr>
<tr>
<td>SYSENTER </td><td></td><td>Fast System Call </td></tr>
<tr>
<td>TEST </td><td></td><td>Logical Compare </td></tr>
<tr>
<td>TZCNT </td><td>bmi1 </td><td>Count the Number of Trailing Zero Bits </td></tr>
<tr>
<td>UNPCKHPD </td><td>sse2 </td><td>Unpack and Interleave High Packed Double- Precision Floating-Point Values </td></tr>
<tr>
<td>UNPCKHPS </td><td>sse1 </td><td>Unpack and Interleave High Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>UNPCKLPD </td><td>sse2 </td><td>Unpack and Interleave Low Packed Double-Precision Floating-Point Values </td></tr>
<tr>
<td>UNPCKLPS </td><td>sse1 </td><td>Unpack and Interleave Low Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>VMOVD </td><td>avx </td><td>VEX Move Doubleword </td></tr>
<tr>
<td>VMOVDQA </td><td>avx </td><td>VEX Move aligned packed integer values </td></tr>
<tr>
<td>VMOVDQU </td><td>avx </td><td>VEX Move unaligned packed integer values </td></tr>
<tr>
<td>VMOVQ </td><td>avx </td><td>VEX Move Quadword </td></tr>
<tr>
<td>VMOVSD </td><td>avx </td><td>VEX Move or Merge Scalar Double-Precision Floating-Point Value </td></tr>
<tr>
<td>VMOVAPS </td><td>avx </td><td>VEX Move Aligned Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>VMOVUPS </td><td>avx </td><td>VEX Move Unaligned Packed Single-Precision Floating-Point Values </td></tr>
<tr>
<td>VPAND </td><td>avx/avx2 </td><td>VEX Logical AND </td></tr>
<tr>
<td>VPANDN </td><td>avx/avx2 </td><td>VEX Logical AND NOT </td></tr>
<tr>
<td>VPEXTRB </td><td>avx/avx2 </td><td>VEX Extract Byte </td></tr>
<tr>
<td>VPEXTRD </td><td>avx/avx2 </td><td>VEX Extract Dword </td></tr>
<tr>
<td>VPEXTRQ </td><td>avx/avx2 </td><td>VEX Extract Qword </td></tr>
<tr>
<td>VPEXTRW </td><td>avx/avx2 </td><td>VEX Extract Word </td></tr>
<tr>
<td>VPBROADCASTB </td><td>avx2 </td><td>VEX Load Byte Integer and broadcast </td></tr>
<tr>
<td>VPCMPEQB </td><td>avx/avx2 </td><td>VEX Compare packed Bytes for equality </td></tr>
<tr>
<td>VPCMPEQD </td><td>avx/avx2 </td><td>VEX Compare packed Doublewords for equality </td></tr>
<tr>
<td>VPCMPEQQ </td><td>avx/avx2 </td><td>VEX Compare packed Quadwords for equality </td></tr>
<tr>
<td>VPCMPEQW </td><td>avx/avx2 </td><td>VEX Compare packed Words for equality </td></tr>
<tr>
<td>VPCMPGTB </td><td>avx/avx2 </td><td>VEX Compare Packed Bytes for Greater Than </td></tr>
<tr>
<td>VPCMPGTD </td><td>avx/avx2 </td><td>VEX Compare Packed Doublewords for Greater Than </td></tr>
<tr>
<td>VPCMPGTW </td><td>avx/avx2 </td><td>VEX Compare Packed Words for Greater Than </td></tr>
<tr>
<td>VPMOVMSKB </td><td>avx/avx2 </td><td>VEX Move Byte Mask </td></tr>
<tr>
<td>VPMINUB </td><td>avx/avx2 </td><td>VEX Minimum of Packed Unsigned Byte Integers </td></tr>
<tr>
<td>VPOR </td><td>avx/avx2 </td><td>VEX Logical OR </td></tr>
<tr>
<td>VPSHUFD </td><td>avx/avx2 </td><td>VEX Shuffle Packed Doublewords </td></tr>
<tr>
<td>VPSLLDQ </td><td>avx/avx2 </td><td>VEX Byte Shift Double Quadword Left Logical </td></tr>
<tr>
<td>VPSUBB </td><td>avx/avx2 </td><td>VEX Subtract packed Byte integers </td></tr>
<tr>
<td>VPSUBD </td><td>avx/avx2 </td><td>VEX Subtract packed Doubleword integers </td></tr>
<tr>
<td>VPSUBQ </td><td>avx/avx2 </td><td>VEX Subtract packed Quadword integers </td></tr>
<tr>
<td>VPSUBW </td><td>avx/avx2 </td><td>VEX Subtract packed Word integers </td></tr>
<tr>
<td>VPTEST </td><td>avx </td><td>VEX Logical Compare </td></tr>
<tr>
<td>VPXOR </td><td>avx/avx2 </td><td>VEX Logical XOR </td></tr>
<tr>
<td>VXORPS </td><td>avx </td><td>VEX Bitwise Logical XOR for Single-Precision Floating-Point Values </td></tr>
<tr>
<td>WAIT </td><td></td><td>Wait </td></tr>
<tr>
<td>WBINVD </td><td></td><td>Write Back and Invalidate Cache </td></tr>
<tr>
<td>XADD </td><td></td><td>Exchange and Add </td></tr>
<tr>
<td>XCHG </td><td></td><td>Exchange Register/Memory with Register </td></tr>
<tr>
<td>XOR </td><td></td><td>Logical Exclusive OR </td></tr>
<tr>
<td>XORPD </td><td>sse2 </td><td>Bitwise Logical XOR for Double-Precision Floating-Point Values </td></tr>
<tr>
<td>XORPS </td><td>sse1 </td><td>Bitwise Logical XOR for Single-Precision Floating-Point Values </td></tr>
</table>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
