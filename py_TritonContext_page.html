<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TritonContext</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libTriton
   &#160;<span id="projectnumber">version 0.9 build 1503</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">TritonContext </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<b>python api</b>] All information about the Triton Context class</p>
<p><a class="anchor" id="tritonContext"></a> </p>
<h1><a class="anchor" id="triton_py_description"></a>
Description</h1>
<hr/>
<p>libTriton offers Python bindings on top of its C++ API which allow you to build analysis in Python as well as in C++.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">from</span> triton <span class="keyword">import</span> TritonContext, ARCH</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; ctx1 = TritonContext()</div><div class="line">&gt;&gt;&gt; ctx1.setArchitecture(ARCH.X86_64)</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; ctx2 = TritonContext(ARCH.AARCH64)</div></div><!-- fragment --><h1><a class="anchor" id="tritonContext_py_api"></a>
Python API - Methods of the TritonContext class</h1>
<hr/>
<h2><a class="anchor" id="TritonContext_py_api_methods"></a>
Methods</h2>
<ul>
<li><b>void addCallback(<a class="el" href="py_CALLBACK_page.html">CALLBACK</a> kind, function cb)</b><br />
 Adds a callback at specific internal points. Your callback will be called each time the point is reached.</li>
<li><b>void assignSymbolicExpressionToMemory(<a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> symExpr, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Assigns a <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> to a <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> area. <b>Be careful</b>, use this function only if you know what you are doing. The symbolic expression (<code>symExpr</code>) must be aligned to the memory access.</li>
<li><b>void assignSymbolicExpressionToRegister(<a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> symExpr, <a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Assigns a <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> to a <a class="el" href="py_Register_page.html">Register</a>. <b>Be careful</b>, use this function only if you know what you are doing. The symbolic expression (<code>symExpr</code>) must be aligned to the targeted size register. The register must be a parent register.</li>
<li><b>bool buildSemantics(<a class="el" href="py_Instruction_page.html">Instruction</a> inst)</b><br />
 Builds the instruction semantics. Returns true if the instruction is supported. You must define an architecture before.</li>
<li><b>void clearCallbacks(void)</b><br />
 Clears recorded callbacks.</li>
<li><b>void clearModes(void)</b><br />
 Clears recorded modes.</li>
<li><b>void clearConcreteMemoryValue(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Clears concrete values assigned to the memory cells.</li>
<li><b>void clearConcreteMemoryValue(integer addr, integer size)</b><br />
 Clears concrete values assigned to the memory cells from <code>addr</code> to <code>addr + size</code>.</li>
<li><b>void clearPathConstraints(void)</b><br />
 Clears the current path predicate.</li>
<li><b>void concretizeAllMemory(void)</b><br />
 Concretizes all symbolic memory references.</li>
<li><b>void concretizeAllRegister(void)</b><br />
 Concretizes all symbolic register references.</li>
<li><b>void concretizeMemory(integer addr)</b><br />
 Concretizes a specific symbolic memory reference.</li>
<li><b>void concretizeMemory(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Concretizes a specific symbolic memory reference.</li>
<li><b>void concretizeRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Concretizes a specific symbolic register reference.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> createSymbolicMemoryExpression(<a class="el" href="py_Instruction_page.html">Instruction</a> inst, <a class="el" href="py_AstNode_page.html">AstNode</a> node, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem, string comment)</b><br />
 Returns the new symbolic memory expression and links this expression to the instruction.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> createSymbolicRegisterExpression(<a class="el" href="py_Instruction_page.html">Instruction</a> inst, <a class="el" href="py_AstNode_page.html">AstNode</a> node, <a class="el" href="py_Register_page.html">Register</a> reg, string comment)</b><br />
 Returns the new symbolic register expression and links this expression to the instruction.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> createSymbolicVolatileExpression (<a class="el" href="py_Instruction_page.html">Instruction</a> inst, <a class="el" href="py_AstNode_page.html">AstNode</a> node, string comment)</b><br />
 Returns the new symbolic volatile expression and links this expression to the instruction.</li>
<li><b>void disassembly(<a class="el" href="py_Instruction_page.html">Instruction</a> inst)</b><br />
 Disassembles the instruction and sets up operands. You must define an architecture before.</li>
<li><b>[<a class="el" href="py_Instruction_page.html">Instruction</a> inst, ...] disassembly(integer addr, integer count)</b><br />
 Disassembles a concrete memory area from <code>addr</code> and returns a list of at most <code>count</code> disassembled instructions.</li>
<li><b>[<a class="el" href="py_Instruction_page.html">Instruction</a> inst, ...] disassembly(integer addr)</b><br />
 Disassembles a concrete memory area from <code>addr</code> to control flow instruction and returns a list of disassembled instructions.</li>
<li><b>void enableSymbolicEngine(bool flag)</b><br />
 Enables or disables the symbolic execution engine.</li>
<li><b>void enableTaintEngine(bool flag)</b><br />
 Enables or disables the taint engine.</li>
<li><b>integer evaluateAstViaZ3(<a class="el" href="py_AstNode_page.html">AstNode</a> node)</b><br />
 Evaluates an AST via Z3 and returns the symbolic value.</li>
<li><b>[<a class="el" href="py_Register_page.html">Register</a>, ...] getAllRegisters(void)</b><br />
 Returns the list of all registers. Each item of this list is a <a class="el" href="py_Register_page.html">Register</a>.</li>
<li><b><a class="el" href="py_ARCH_page.html">ARCH</a> getArchitecture(void)</b><br />
 Returns the current architecture used.</li>
<li><b><a class="el" href="py_AstContext_page.html">AstContext</a> getAstContext(void)</b><br />
 Returns the AST context to create and modify nodes.</li>
<li><b><a class="el" href="py_AST_REPRESENTATION_page.html">AST_REPRESENTATION</a> getAstRepresentationMode(void)</b><br />
 Returns the current AST representation mode.</li>
<li><b>bytes getConcreteMemoryAreaValue(integer baseAddr, integer size)</b><br />
 Returns the concrete value of a memory area.</li>
<li><b>integer getConcreteMemoryValue(integer addr)</b><br />
 Returns the concrete value of a memory cell.</li>
<li><b>integer getConcreteMemoryValue(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns the concrete value of memory cells.</li>
<li><b>integer getConcreteRegisterValue(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns the concrete value of a register.</li>
<li><b>integer getConcreteVariableValue(<a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> symVar)</b><br />
 Returns the concrete value of a symbolic variable.</li>
<li><b>integer getGprBitSize(void)</b><br />
 Returns the size in bits of the General Purpose Registers.</li>
<li><b>integer getGprSize(void)</b><br />
 Returns the size in bytes of the General Purpose Registers.</li>
<li><b><a class="el" href="py_AstNode_page.html">AstNode</a> getImmediateAst(<a class="el" href="py_Immediate_page.html">Immediate</a> imm)</b><br />
 Returns the AST corresponding to the <a class="el" href="py_Immediate_page.html">Immediate</a>.</li>
<li><b><a class="el" href="py_AstNode_page.html">AstNode</a> getMemoryAst(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns the AST corresponding to the <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> with the SSA form.</li>
<li><b>dict getModel(<a class="el" href="py_AstNode_page.html">AstNode</a> node, status=False)</b><br />
 Computes and returns a model as a dictionary of {integer symVarId : <a class="el" href="py_SolverModel_page.html">SolverModel</a> model} from a symbolic constraint. If status is True, returns a tuple of (dict, <a class="el" href="py_SOLVER_page.html">SOLVER</a> status).</li>
<li><b>[dict, ...] getModels(<a class="el" href="py_AstNode_page.html">AstNode</a> node, integer limit, status=False)</b><br />
 Computes and returns several models from a symbolic constraint. The <code>limit</code> is the number of models returned. If status is True, returns a tuple of ([dict, ...], <a class="el" href="py_SOLVER_page.html">SOLVER</a> status).</li>
<li><b><a class="el" href="py_Register_page.html">Register</a> getParentRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns the parent <a class="el" href="py_Register_page.html">Register</a> from a <a class="el" href="py_Register_page.html">Register</a>.</li>
<li><b>[<a class="el" href="py_Register_page.html">Register</a>, ...] getParentRegisters(void)</b><br />
 Returns the list of parent registers. Each item of this list is a <a class="el" href="py_Register_page.html">Register</a>.</li>
<li><b>[<a class="el" href="py_PathConstraint_page.html">PathConstraint</a>, ...] getPathConstraints(void)</b><br />
 Returns the logical conjunction vector of path constraints as a list of <a class="el" href="py_PathConstraint_page.html">PathConstraint</a>.</li>
<li><b><a class="el" href="py_AstNode_page.html">AstNode</a> getPathPredicate(void)</b><br />
 Returns the current path predicate as an AST of logical conjunction of each taken branch.</li>
<li><b>integer getPathPredicateSize(void)</b><br />
 Returns the size of the path predicate (number of constraints).</li>
<li><b>[<a class="el" href="py_AstNode_page.html">AstNode</a>, ...] getPredicatesToReachAddress(integer addr)</b><br />
 Returns path predicates which may reach the targeted address.</li>
<li><b><a class="el" href="py_Register_page.html">Register</a> getRegister(<a class="el" href="py_REG_page.html">REG</a> id)</b><br />
 Returns the <a class="el" href="py_Register_page.html">Register</a> class corresponding to a <a class="el" href="py_REG_page.html">REG</a> id.</li>
<li><b><a class="el" href="py_Register_page.html">Register</a> getRegister(string name)</b><br />
 Returns the <a class="el" href="py_Register_page.html">Register</a> class corresponding to a string.</li>
<li><b><a class="el" href="py_AstNode_page.html">AstNode</a> getRegisterAst(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns the AST corresponding to the <a class="el" href="py_Register_page.html">Register</a> with the SSA form.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> getSymbolicExpression(integer symExprId)</b><br />
 Returns the symbolic expression corresponding to an id.</li>
<li><b>dict getSymbolicExpressions(void)</b><br />
 Returns all symbolic expressions as a dictionary of {integer SymExprId : <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr}.</li>
<li><b>dict getSymbolicMemory(void)</b><br />
 Returns the map of symbolic memory as {integer address : <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr}.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> getSymbolicMemory(integer addr)</b><br />
 Returns the <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> corresponding to a memory address.</li>
<li><b>integer getSymbolicMemoryValue(integer addr)</b><br />
 Returns the symbolic memory value.</li>
<li><b>integer getSymbolicMemoryValue(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns the symbolic memory value.</li>
<li><b>dict getSymbolicRegisters(void)</b><br />
 Returns the map of symbolic registers as {<a class="el" href="py_REG_page.html">REG</a> reg : <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr}.</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> getSymbolicRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns the <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> corresponding to the parent register.</li>
<li><b>integer getSymbolicRegisterValue(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns the symbolic register value.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> getSymbolicVariable(integer symVarId)</b><br />
 Returns the symbolic variable corresponding to a symbolic variable id.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> getSymbolicVariable(string symVarName)</b><br />
 Returns the symbolic variable corresponding to a symbolic variable name.</li>
<li><b>dict getSymbolicVariables(void)</b><br />
 Returns all symbolic variables as a dictionary of {integer SymVarId : <a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> var}.</li>
<li><b>[integer, ...] getTaintedMemory(void)</b><br />
 Returns the list of all tainted addresses.</li>
<li><b>[<a class="el" href="py_Register_page.html">Register</a>, ...] getTaintedRegisters(void)</b><br />
 Returns the list of all tainted registers.</li>
<li><b>[<a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a>, ...] getTaintedSymbolicExpressions(void)</b><br />
 Returns the list of all tainted symbolic expressions.</li>
<li><b>bool isArchitectureValid(void)</b><br />
 Returns true if the architecture is valid.</li>
<li><b>bool isConcreteMemoryValueDefined(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns true if memory cells have a defined concrete value.</li>
<li><b>bool isConcreteMemoryValueDefined(integer addr, integer size)</b><br />
 Returns true if memory cells have a defined concrete value.</li>
<li><b>bool isFlag(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns true if the register is a flag.</li>
<li><b>bool isMemorySymbolized(integer addr)</b><br />
 Returns true if the memory cell expression contains a symbolic variable.</li>
<li><b>bool isMemorySymbolized(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns true if memory cell expressions contain symbolic variables.</li>
<li><b>bool isMemoryTainted(integer addr)</b><br />
 Returns true if the address is tainted.</li>
<li><b>bool isMemoryTainted(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Returns true if the memory is tainted.</li>
<li><b>bool isModeEnabled(<a class="el" href="py_MODE_page.html">MODE</a> mode)</b><br />
 Returns true if the mode is enabled.</li>
<li><b>bool isRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns true if the register is a register (see also isFlag()).</li>
<li><b>bool isRegisterSymbolized(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns true if the register expression contains a symbolic variable.</li>
<li><b>bool isRegisterTainted(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns true if the register is tainted.</li>
<li><b>bool isRegisterValid(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Returns true if the register is valid.</li>
<li><b>bool isSat(<a class="el" href="py_AstNode_page.html">AstNode</a> node)</b><br />
 Returns true if an expression is satisfiable.</li>
<li><b>bool isSymbolicEngineEnabled(void)</b><br />
 Returns true if the symbolic execution engine is enabled.</li>
<li><b>bool isSymbolicExpressionExists(integer symExprId)</b><br />
 Returns true if the symbolic expression id exists.</li>
<li><b>bool isTaintEngineEnabled(void)</b><br />
 Returns true if the taint engine is enabled.</li>
<li><b>bool isThumb(void)</b><br />
 Returns true if execution mode is Thumb (only valid for ARM32).</li>
<li><b><a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> newSymbolicExpression(<a class="el" href="py_AstNode_page.html">AstNode</a> node, string comment)</b><br />
 Returns a new symbolic expression. Note that if there are simplification passes recorded, simplifications will be applied.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> newSymbolicVariable(integer varSize, string alias)</b><br />
 Returns a new symbolic variable.</li>
<li><b>void popPathConstraint(void)</b><br />
 Pops the last constraints added to the path predicate.</li>
<li><b>void printSlicedExpressions(<a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr, bool assert_=False)</b><br />
 Prints symbolic expression with used references and symbolic variables in AST representation mode. If <code>assert_</code> is true, then (assert &lt;expr&gt;).</li>
<li><b>bool processing(<a class="el" href="py_Instruction_page.html">Instruction</a> inst)</b><br />
 Processes an instruction and updates engines according to the instruction semantics. Returns true if the instruction is supported. You must define an architecture before.</li>
<li><b>void pushPathConstraint(<a class="el" href="py_AstNode_page.html">AstNode</a> node)</b><br />
 Pushs constraints to the current path predicate.</li>
<li><b>void removeCallback(<a class="el" href="py_CALLBACK_page.html">CALLBACK</a> kind, function cb)</b><br />
 Removes a recorded callback.</li>
<li><b>void reset(void)</b><br />
 Resets everything.</li>
<li><b>void setArchitecture(<a class="el" href="py_ARCH_page.html">ARCH</a> arch)</b><br />
 Initializes an architecture. This function must be called before any call to the rest of the API.</li>
<li><b>void setAstRepresentationMode(<a class="el" href="py_AST_REPRESENTATION_page.html">AST_REPRESENTATION</a> mode)</b><br />
 Sets the AST representation mode.</li>
<li><b>void setConcreteMemoryAreaValue(integer baseAddr, [integer,])</b><br />
 Sets the concrete value of a memory area. Note that setting a concrete value will probably imply a desynchronization with the symbolic state (if it exists). You should probably use the concretize functions after this.</li>
<li><b>void setConcreteMemoryAreaValue(integer baseAddr, bytes opcodes)</b><br />
 Sets the concrete value of a memory area. Note that setting a concrete value will probably imply a desynchronization with the symbolic state (if it exists). You should probably use the concretize functions after this.</li>
<li><b>void setConcreteMemoryValue(integer addr, integer value)</b><br />
 Sets the concrete value of a memory cell. Note that setting a concrete value will probably imply a desynchronization with the symbolic state (if it exists). You should probably use the concretize functions after this.</li>
<li><b>void setConcreteMemoryValue(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem, integer value)</b><br />
 Sets the concrete value of memory cells. Note that setting a concrete value will probably imply a desynchronization with the symbolic state (if it exists). You should probably use the concretize functions after this.</li>
<li><b>void setConcreteRegisterValue(<a class="el" href="py_Register_page.html">Register</a> reg, integer value)</b><br />
 Sets the concrete value of a register. Note that setting a concrete value will probably imply a desynchronization with the symbolic state (if it exists). You should probably use the concretize functions after this.</li>
<li><b>void setConcreteVariableValue(<a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> symVar, integer value)</b><br />
 Sets the concrete value of a symbolic variable.</li>
<li><b>void setMode(<a class="el" href="py_MODE_page.html">MODE</a> mode, bool flag)</b><br />
 Enables or disables a specific mode.</li>
<li><b>void setSolverMemoryLimit(integer megabytes)</b><br />
 Defines a solver memory consumption limit (in megabytes)</li>
<li><b>void setSolverTimeout(integer ms)</b><br />
 Defines a solver timeout (in milliseconds)</li>
<li><b>bool setTaintMemory(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem, bool flag)</b><br />
 Sets the targeted memory as tainted or not. Returns true if the memory is still tainted.</li>
<li><b>bool setTaintRegister(<a class="el" href="py_Register_page.html">Register</a> reg, bool flag)</b><br />
 Sets the targeted register as tainted or not. Returns true if the register is still tainted.</li>
<li><b>void setThumb(bool state)</b><br />
 Sets CPU state to Thumb mode (only valid for ARM32).</li>
<li><b><a class="el" href="py_AstNode_page.html">AstNode</a> simplify(<a class="el" href="py_AstNode_page.html">AstNode</a> node, bool z3=False)</b><br />
 Calls all simplification callbacks recorded and returns a new simplified node. If the <code>z3</code> flag is set to True, Triton will use z3 to simplify the given <code>node</code> before calling its recorded callbacks.</li>
<li><b>dict sliceExpressions(<a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr)</b><br />
 Slices expressions from a given one (backward slicing) and returns all symbolic expressions as a dictionary of {integer SymExprId : <a class="el" href="py_SymbolicExpression_page.html">SymbolicExpression</a> expr}.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> symbolizeExpression(integer symExprId, integer symVarSize, string symVarAlias)</b><br />
 Converts a symbolic expression to a symbolic variable. <code>symVarSize</code> must be in bits. This function returns the new symbolic variable created.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> symbolizeMemory(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem, string symVarAlias)</b><br />
 Converts a symbolic memory expression to a symbolic variable. This function returns the new symbolic variable created.</li>
<li><b><a class="el" href="py_SymbolicVariable_page.html">SymbolicVariable</a> symbolizeRegister(<a class="el" href="py_Register_page.html">Register</a> reg, string symVarAlias)</b><br />
 Converts a symbolic register expression to a symbolic variable. This function returns the new symbolic variable created.</li>
<li><b>bool taintAssignment(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_Immediate_page.html">Immediate</a> immSrc)</b><br />
 Taints <code>memDst</code> from <code>immSrc</code> with an assignment - <code>memDst</code> is untained. Returns true if the <code>memDst</code> is still tainted.</li>
<li><b>bool taintAssignment(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memSrc)</b><br />
 Taints <code>memDst</code> from <code>memSrc</code> with an assignment - <code>memDst</code> is tainted if <code>memSrc</code> is tainted, otherwise <code>memDst</code> is untained. Returns true if <code>memDst</code> is tainted.</li>
<li><b>bool taintAssignment(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_Register_page.html">Register</a> regSrc)</b><br />
 Taints <code>memDst</code> from <code>regSrc</code> with an assignment - <code>memDst</code> is tainted if <code>regSrc</code> is tainted, otherwise <code>memDst</code> is untained. Return true if <code>memDst</code> is tainted.</li>
<li><b>bool taintAssignment(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_Immediate_page.html">Immediate</a> immSrc)</b><br />
 Taints <code>regDst</code> from <code>immSrc</code> with an assignment - <code>regDst</code> is untained. Returns true if <code>reDst</code> is still tainted.</li>
<li><b>bool taintAssignment(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memSrc)</b><br />
 Taints <code>regDst</code> from <code>MemSrc</code> with an assignment - <code>regDst</code> is tainted if <code>memSrc</code> is tainted, otherwise <code>regDst</code> is untained. Return true if <code>regDst</code> is tainted.</li>
<li><b>bool taintAssignment(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_Register_page.html">Register</a> regSrc)</b><br />
 Taints <code>regDst</code> from <code>regSrc</code> with an assignment - <code>regDst</code> is tainted if <code>regSrc</code> is tainted, otherwise <code>regDst</code> is untained. Return true if <code>regDst</code> is tainted.</li>
<li><b>bool taintMemory(integer addr)</b><br />
 Taints an address. Returns true if the address is tainted.</li>
<li><b>bool taintMemory(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Taints a memory. Returns true if the memory is tainted.</li>
<li><b>bool taintRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Taints a register. Returns true if the register is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_Immediate_page.html">Immediate</a> immSrc)</b><br />
 Taints <code>memDst</code> from <code>immSrc</code> with an union - <code>memDst</code> does not changes. Returns true if <code>memDst</code> is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memSrc)</b><br />
 Taints <code>memDst</code> from <code>memSrc</code> with an union - <code>memDst</code> is tainted if <code>memDst</code> or <code>memSrc</code> are tainted. Returns true if <code>memDst</code> is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memDst, <a class="el" href="py_Register_page.html">Register</a> regSrc)</b><br />
 Taints <code>memDst</code> from <code>RegSrc</code> with an union - <code>memDst</code> is tainted if <code>memDst</code> or <code>regSrc</code> are tainted. Returns true if <code>memDst</code> is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_Immediate_page.html">Immediate</a> immSrc)</b><br />
 Taints <code>regDst</code> from <code>immSrc</code> with an union - <code>regDst</code> does not changes. Returns true if <code>regDst</code> is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> memSrc)</b><br />
 Taints <code>regDst</code> from <code>memSrc</code> with an union - <code>regDst</code> is tainted if <code>regDst</code> or <code>memSrc</code> are tainted. Returns true if <code>regDst</code> is tainted.</li>
<li><b>bool taintUnion(<a class="el" href="py_Register_page.html">Register</a> regDst, <a class="el" href="py_Register_page.html">Register</a> regSrc)</b><br />
 Taints <code>regDst</code> from <code>regSrc</code> with an union - <code>regDst</code> is tainted if <code>regDst</code> or <code>regSrc</code> are tainted. Returns true if <code>regDst</code> is tainted.</li>
<li><b>bool untaintMemory(integer addr)</b><br />
 Untaints an address. Returns true if the address is still tainted.</li>
<li><b>bool untaintMemory(<a class="el" href="py_MemoryAccess_page.html">MemoryAccess</a> mem)</b><br />
 Untaints a memory. Returns true if the memory is still tainted.</li>
<li><b>bool untaintRegister(<a class="el" href="py_Register_page.html">Register</a> reg)</b><br />
 Untaints a register. Returns true if the register is still tainted. </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
